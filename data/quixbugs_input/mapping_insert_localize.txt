0<MAP>INT_1 <SEP> 1<MAP>INT_2 <SEP> bitcount<MAP>METHOD_1 <SEP> count<MAP>VAR_2 <SEP> n<MAP>VAR_1 <SEP> 	
add<MAP>METHOD_3 <SEP> getSuccessors<MAP>METHOD_5 <SEP> startnode<MAP>VAR_1 <SEP> Node<MAP>TYPE_1 <SEP> successor_node<MAP>VAR_6 <SEP> Deque<MAP>TYPE_2 <SEP> goalnode<MAP>VAR_2 <SEP> ArrayDeque<MAP>TYPE_3 <SEP> addLast<MAP>METHOD_2 <SEP> node<MAP>VAR_5 <SEP> contains<MAP>METHOD_6 <SEP> breadth_first_search<MAP>METHOD_1 <SEP> removeFirst<MAP>METHOD_4 <SEP> addFirst<MAP>METHOD_7 <SEP> queue<MAP>VAR_3 <SEP> nodesvisited<MAP>VAR_4 <SEP> 	
arr<MAP>VAR_1 <SEP> set<MAP>METHOD_3 <SEP> counts<MAP>VAR_3 <SEP> ArrayList<MAP>TYPE_1 <SEP> count<MAP>VAR_7 <SEP> i<MAP>VAR_6 <SEP> k<MAP>VAR_2 <SEP> bucketsort<MAP>METHOD_1 <SEP> Integer<MAP>TYPE_2 <SEP> 0<MAP>INT_1 <SEP> 1<MAP>INT_2 <SEP> 100<MAP>INT_3 <SEP> nCopies<MAP>METHOD_2 <SEP> addAll<MAP>METHOD_5 <SEP> sorted_arr<MAP>VAR_5 <SEP> get<MAP>METHOD_4 <SEP> x<MAP>VAR_4 <SEP> Collections<MAP>TYPE_3 <SEP> 	
node<MAP>VAR_1 <SEP> search<MAP>METHOD_1 <SEP> contains<MAP>METHOD_2 <SEP> getSuccessors<MAP>METHOD_3 <SEP> Node<MAP>TYPE_1 <SEP> goalnode<MAP>VAR_3 <SEP> nodesvisited<MAP>VAR_2 <SEP> successornodes<MAP>VAR_4 <SEP> 	
node<MAP>VAR_1 <SEP> getSuccessor<MAP>METHOD_2 <SEP> tortoise<MAP>VAR_3 <SEP> Node<MAP>TYPE_1 <SEP> hare<MAP>VAR_2 <SEP> detect_cycle<MAP>METHOD_1 <SEP> 	
arr<MAP>VAR_1 <SEP> 0<MAP>INT_1 <SEP> hi<MAP>VAR_4 <SEP> 1<MAP>INT_3 <SEP> 2<MAP>INT_2 <SEP> lo<MAP>VAR_3 <SEP> find_first_in_sorted<MAP>METHOD_1 <SEP> x<MAP>VAR_2 <SEP> length<MAP>VAR_5 <SEP> mid<MAP>VAR_6 <SEP> 	
arr<MAP>VAR_1 <SEP> 1<MAP>INT_1 <SEP> 2<MAP>INT_2 <SEP> x<MAP>VAR_2 <SEP> start<MAP>VAR_3 <SEP> mid<MAP>VAR_5 <SEP> binsearch<MAP>METHOD_1 <SEP> end<MAP>VAR_4 <SEP> 	
	
0<MAP>INT_1 <SEP> a<MAP>VAR_1 <SEP> b<MAP>VAR_2 <SEP> gcd<MAP>METHOD_1 <SEP> 	
add<MAP>METHOD_3 <SEP> get_factors<MAP>METHOD_1 <SEP> max<MAP>VAR_2 <SEP> ArrayList<MAP>TYPE_1 <SEP> prepend<MAP>VAR_4 <SEP> i<MAP>VAR_3 <SEP> Math<MAP>TYPE_3 <SEP> n<MAP>VAR_1 <SEP> Integer<MAP>TYPE_2 <SEP> 0<MAP>INT_3 <SEP> 1<MAP>INT_1 <SEP> 2<MAP>INT_2 <SEP> 1.0<MAP>FLOAT_1 <SEP> sqrt<MAP>METHOD_2 <SEP> addAll<MAP>METHOD_4 <SEP> 	
add<MAP>METHOD_2 <SEP> ArrayList<MAP>TYPE_4 <SEP> hanoi<MAP>METHOD_1 <SEP> start<MAP>VAR_2 <SEP> poll<MAP>METHOD_4 <SEP> PriorityQueue<MAP>TYPE_5 <SEP> steps<MAP>VAR_4 <SEP> remove<MAP>METHOD_3 <SEP> Integer<MAP>TYPE_3 <SEP> 0<MAP>INT_1 <SEP> 1<MAP>INT_2 <SEP> 2<MAP>INT_3 <SEP> 3<MAP>INT_4 <SEP> helper<MAP>VAR_6 <SEP> addAll<MAP>METHOD_5 <SEP> crap_set<MAP>VAR_5 <SEP> List<MAP>TYPE_1 <SEP> end<MAP>VAR_3 <SEP> Pair<MAP>TYPE_2 <SEP> height<MAP>VAR_1 <SEP> 	
parens<MAP>VAR_1 <SEP> Character<MAP>TYPE_3 <SEP> '('<MAP>CHAR_1 <SEP> length<MAP>METHOD_2 <SEP> is_valid_parenthesization<MAP>METHOD_1 <SEP> i<MAP>VAR_3 <SEP> String<MAP>TYPE_2 <SEP> 0<MAP>INT_1 <SEP> paren<MAP>VAR_4 <SEP> depth<MAP>VAR_2 <SEP> equals<MAP>METHOD_4 <SEP> Boolean<MAP>TYPE_1 <SEP> charAt<MAP>METHOD_3 <SEP> 	
add<MAP>METHOD_3 <SEP> arr<MAP>VAR_1 <SEP> subList<MAP>METHOD_2 <SEP> kheapsort<MAP>METHOD_1 <SEP> ArrayList<MAP>TYPE_1 <SEP> isEmpty<MAP>METHOD_5 <SEP> poll<MAP>METHOD_4 <SEP> k<MAP>VAR_2 <SEP> PriorityQueue<MAP>TYPE_3 <SEP> Integer<MAP>TYPE_2 <SEP> output<MAP>VAR_5 <SEP> 0<MAP>INT_1 <SEP> popped<MAP>VAR_7 <SEP> v<MAP>VAR_4 <SEP> x<MAP>VAR_6 <SEP> heap<MAP>VAR_3 <SEP> 	
max<MAP>METHOD_2 <SEP> length<MAP>VAR_6 <SEP> weight<MAP>VAR_3 <SEP> memo<MAP>VAR_7 <SEP> i<MAP>VAR_8 <SEP> j<MAP>VAR_9 <SEP> Math<MAP>TYPE_1 <SEP> n<MAP>VAR_5 <SEP> capacity<MAP>VAR_1 <SEP> 0<MAP>INT_1 <SEP> 1<MAP>INT_2 <SEP> knapsack<MAP>METHOD_1 <SEP> items<MAP>VAR_2 <SEP> value<MAP>VAR_4 <SEP> 	
add<MAP>METHOD_4 <SEP> arr<MAP>VAR_1 <SEP> below<MAP>VAR_4 <SEP> ArrayList<MAP>TYPE_2 <SEP> k<MAP>VAR_2 <SEP> Integer<MAP>TYPE_1 <SEP> 0<MAP>INT_1 <SEP> size<MAP>METHOD_3 <SEP> num_less<MAP>VAR_7 <SEP> get<MAP>METHOD_2 <SEP> above<MAP>VAR_5 <SEP> x<MAP>VAR_6 <SEP> pivot<MAP>VAR_3 <SEP> kth<MAP>METHOD_1 <SEP> num_lessoreq<MAP>VAR_8 <SEP> 	
	
levenshtein<MAP>METHOD_1 <SEP> 0<MAP>INT_1 <SEP> 1<MAP>INT_2 <SEP> min<MAP>METHOD_6 <SEP> isEmpty<MAP>METHOD_2 <SEP> length<MAP>METHOD_3 <SEP> String<MAP>TYPE_1 <SEP> source<MAP>VAR_1 <SEP> Math<MAP>TYPE_2 <SEP> charAt<MAP>METHOD_4 <SEP> substring<MAP>METHOD_5 <SEP> target<MAP>VAR_2 <SEP> 	
add<MAP>METHOD_3 <SEP> arr<MAP>VAR_1 <SEP> val<MAP>VAR_5 <SEP> longest<MAP>VAR_3 <SEP> HashMap<MAP>TYPE_3 <SEP> max<MAP>METHOD_5 <SEP> ArrayList<MAP>TYPE_4 <SEP> isEmpty<MAP>METHOD_4 <SEP> length<MAP>VAR_8 <SEP> i<MAP>VAR_4 <SEP> j<MAP>VAR_7 <SEP> put<MAP>METHOD_6 <SEP> Integer<MAP>TYPE_2 <SEP> 0<MAP>INT_2 <SEP> 100<MAP>INT_1 <SEP> 1<MAP>INT_3 <SEP> prefix_lengths<MAP>VAR_6 <SEP> lis<MAP>METHOD_1 <SEP> get<MAP>METHOD_2 <SEP> ends<MAP>VAR_2 <SEP> Collections<MAP>TYPE_5 <SEP> Map<MAP>TYPE_1 <SEP> 	
""<MAP>STRING_1 <SEP> a<MAP>VAR_1 <SEP> b<MAP>VAR_2 <SEP> fst<MAP>VAR_3 <SEP> isEmpty<MAP>METHOD_2 <SEP> length<MAP>METHOD_5 <SEP> snd<MAP>VAR_4 <SEP> String<MAP>TYPE_1 <SEP> substring<MAP>METHOD_4 <SEP> 0<MAP>INT_1 <SEP> 1<MAP>INT_2 <SEP> longest_common_subsequence<MAP>METHOD_1 <SEP> charAt<MAP>METHOD_3 <SEP> 	
arr<MAP>VAR_1 <SEP> 0<MAP>INT_1 <SEP> max_ending_here<MAP>VAR_2 <SEP> max<MAP>METHOD_2 <SEP> x<MAP>VAR_4 <SEP> max_sublist_sum<MAP>METHOD_1 <SEP> max_so_far<MAP>VAR_3 <SEP> Math<MAP>TYPE_1 <SEP> 	
arr<MAP>VAR_1 <SEP> subList<MAP>METHOD_4 <SEP> middle<MAP>VAR_2 <SEP> ArrayList<MAP>TYPE_1 <SEP> right<MAP>VAR_4 <SEP> Integer<MAP>TYPE_2 <SEP> 0<MAP>INT_1 <SEP> 100<MAP>INT_3 <SEP> 2<MAP>INT_2 <SEP> size<MAP>METHOD_2 <SEP> addAll<MAP>METHOD_3 <SEP> left<MAP>VAR_3 <SEP> merge<MAP>METHOD_5 <SEP> mergesort<MAP>METHOD_1 <SEP> 	
Set<MAP>TYPE_1 <SEP> HashMap<MAP>TYPE_6 <SEP> Node<MAP>TYPE_5 <SEP> update<MAP>METHOD_8 <SEP> put<MAP>METHOD_4 <SEP> asList<MAP>METHOD_5 <SEP> edge<MAP>VAR_4 <SEP> get<MAP>METHOD_6 <SEP> List<MAP>TYPE_3 <SEP> Collections<MAP>TYPE_8 <SEP> weightedEdges<MAP>VAR_1 <SEP> WeightedEdge<MAP>TYPE_2 <SEP> HashSet<MAP>TYPE_7 <SEP> add<MAP>METHOD_7 <SEP> vertex_u<MAP>VAR_5 <SEP> vertex_v<MAP>VAR_7 <SEP> minSpanningTree<MAP>VAR_3 <SEP> containsKey<MAP>METHOD_3 <SEP> sort<MAP>METHOD_2 <SEP> groupByNode<MAP>VAR_2 <SEP> node1<MAP>VAR_6 <SEP> node<MAP>VAR_9 <SEP> node2<MAP>VAR_8 <SEP> minimum_spanning_tree<MAP>METHOD_1 <SEP> Arrays<MAP>TYPE_9 <SEP> Map<MAP>TYPE_4 <SEP> 	
add<MAP>METHOD_4 <SEP> otherwise<MAP>VAR_5 <SEP> valueOf<MAP>METHOD_7 <SEP> ArrayList<MAP>TYPE_4 <SEP> length<MAP>VAR_3 <SEP> String<MAP>TYPE_1 <SEP> Math<MAP>TYPE_2 <SEP> Integer<MAP>TYPE_5 <SEP> 0<MAP>INT_3 <SEP> 1<MAP>INT_2 <SEP> 2<MAP>INT_1 <SEP> nCopies<MAP>METHOD_6 <SEP> addAll<MAP>METHOD_5 <SEP> floorDiv<MAP>METHOD_2 <SEP> digit_list<MAP>VAR_1 <SEP> high_mid<MAP>VAR_2 <SEP> low_mid<MAP>VAR_4 <SEP> 9<MAP>INT_4 <SEP> toString<MAP>METHOD_3 <SEP> Arrays<MAP>TYPE_3 <SEP> Collections<MAP>TYPE_6 <SEP> next_palindrome<MAP>METHOD_1 <SEP> 	
add<MAP>METHOD_5 <SEP> next_permutation<MAP>METHOD_1 <SEP> set<MAP>METHOD_4 <SEP> perm<MAP>VAR_1 <SEP> ArrayList<MAP>TYPE_1 <SEP> replace<MAP>VAR_10 <SEP> i<MAP>VAR_2 <SEP> j<MAP>VAR_3 <SEP> temp_i<MAP>VAR_6 <SEP> temp_j<MAP>VAR_5 <SEP> k<MAP>VAR_8 <SEP> Integer<MAP>TYPE_2 <SEP> q<MAP>VAR_9 <SEP> 1<MAP>INT_2 <SEP> 100<MAP>INT_3 <SEP> 2<MAP>INT_1 <SEP> size<MAP>METHOD_2 <SEP> get<MAP>METHOD_3 <SEP> next_perm<MAP>VAR_4 <SEP> reversed<MAP>VAR_7 <SEP> 	
add<MAP>METHOD_2 <SEP> init<MAP>VAR_3 <SEP> upleft<MAP>VAR_7 <SEP> c<MAP>VAR_6 <SEP> pascal<MAP>METHOD_1 <SEP> ArrayList<MAP>TYPE_1 <SEP> rows<MAP>VAR_2 <SEP> n<MAP>VAR_1 <SEP> upright<MAP>VAR_8 <SEP> Integer<MAP>TYPE_2 <SEP> 0<MAP>INT_2 <SEP> 1<MAP>INT_1 <SEP> r<MAP>VAR_4 <SEP> get<MAP>METHOD_3 <SEP> row<MAP>VAR_5 <SEP> 	
0<MAP>INT_1 <SEP> rest<MAP>VAR_4 <SEP> 1<MAP>INT_2 <SEP> copyOfRange<MAP>METHOD_2 <SEP> total<MAP>VAR_2 <SEP> coins<MAP>VAR_1 <SEP> possible_change<MAP>METHOD_1 <SEP> length<MAP>VAR_5 <SEP> Arrays<MAP>TYPE_1 <SEP> first<MAP>VAR_3 <SEP> 	
add<MAP>METHOD_6 <SEP> arr<MAP>VAR_1 <SEP> subList<MAP>METHOD_4 <SEP> middle<MAP>VAR_6 <SEP> ArrayList<MAP>TYPE_1 <SEP> isEmpty<MAP>METHOD_2 <SEP> Integer<MAP>TYPE_2 <SEP> 0<MAP>INT_1 <SEP> 1<MAP>INT_2 <SEP> size<MAP>METHOD_5 <SEP> addAll<MAP>METHOD_7 <SEP> lesser<MAP>VAR_3 <SEP> get<MAP>METHOD_3 <SEP> x<MAP>VAR_5 <SEP> pivot<MAP>VAR_2 <SEP> quicksort<MAP>METHOD_1 <SEP> greater<MAP>VAR_4 <SEP> 	
prevnode<MAP>VAR_2 <SEP> node<MAP>VAR_1 <SEP> getSuccessor<MAP>METHOD_2 <SEP> setSuccessor<MAP>METHOD_3 <SEP> reverse_linked_list<MAP>METHOD_1 <SEP> Node<MAP>TYPE_1 <SEP> nextnode<MAP>VAR_3 <SEP> 	
stack<MAP>VAR_5 <SEP> HashMap<MAP>TYPE_6 <SEP> ArrayList<MAP>TYPE_2 <SEP> String<MAP>TYPE_4 <SEP> put<MAP>METHOD_2 <SEP> pop<MAP>METHOD_5 <SEP> isInstance<MAP>METHOD_3 <SEP> rpn_eval<MAP>METHOD_1 <SEP> get<MAP>METHOD_6 <SEP> tokens<MAP>VAR_1 <SEP> "*"<MAP>STRING_3 <SEP> BinaryOperator<MAP>TYPE_5 <SEP> op<MAP>VAR_2 <SEP> a<MAP>VAR_3 <SEP> b<MAP>VAR_4 <SEP> c<MAP>VAR_7 <SEP> apply<MAP>METHOD_7 <SEP> Double<MAP>TYPE_1 <SEP> push<MAP>METHOD_4 <SEP> Stack<MAP>TYPE_7 <SEP> token<MAP>VAR_6 <SEP> bin_op<MAP>VAR_8 <SEP> 0.0<MAP>FLOAT_1 <SEP> "/"<MAP>STRING_4 <SEP> "-"<MAP>STRING_2 <SEP> "+"<MAP>STRING_1 <SEP> Object<MAP>TYPE_8 <SEP> Map<MAP>TYPE_3 <SEP> 	
Set<MAP>TYPE_6 <SEP> distance<MAP>VAR_8 <SEP> HashMap<MAP>TYPE_5 <SEP> getSuccessors<MAP>METHOD_10 <SEP> startnode<MAP>VAR_2 <SEP> Node<MAP>TYPE_3 <SEP> nextnode<MAP>VAR_9 <SEP> length_by_edge<MAP>VAR_1 <SEP> MAX_VALUE<MAP>VAR_10 <SEP> Math<MAP>TYPE_8 <SEP> goalnode<MAP>VAR_3 <SEP> put<MAP>METHOD_3 <SEP> remove<MAP>METHOD_7 <SEP> asList<MAP>METHOD_13 <SEP> shortest_path_length<MAP>METHOD_1 <SEP> min<MAP>METHOD_12 <SEP> getNodeWithMinDistance<MAP>METHOD_5 <SEP> get<MAP>METHOD_6 <SEP> List<MAP>TYPE_2 <SEP> HashSet<MAP>TYPE_7 <SEP> add<MAP>METHOD_9 <SEP> visitedNodes<MAP>VAR_6 <SEP> isEmpty<MAP>METHOD_4 <SEP> unvisitedNodes<MAP>VAR_5 <SEP> n<MAP>VAR_4 <SEP> Integer<MAP>TYPE_4 <SEP> 0<MAP>INT_1 <SEP> getValue<MAP>METHOD_8 <SEP> node<MAP>VAR_7 <SEP> contains<MAP>METHOD_11 <SEP> size<MAP>METHOD_2 <SEP> Arrays<MAP>TYPE_9 <SEP> Map<MAP>TYPE_1 <SEP> 	
INF<MAP>VAR_7 <SEP> HashMap<MAP>TYPE_4 <SEP> containsKey<MAP>METHOD_4 <SEP> update_length<MAP>VAR_9 <SEP> ArrayList<MAP>TYPE_5 <SEP> i<MAP>VAR_4 <SEP> length_by_edge<MAP>VAR_2 <SEP> j<MAP>VAR_5 <SEP> k<MAP>VAR_8 <SEP> Math<MAP>TYPE_7 <SEP> asList<MAP>METHOD_2 <SEP> put<MAP>METHOD_3 <SEP> Integer<MAP>TYPE_3 <SEP> 0<MAP>INT_1 <SEP> numNodes<MAP>VAR_1 <SEP> edge<MAP>VAR_6 <SEP> min<MAP>METHOD_6 <SEP> shortest_path_lengths<MAP>METHOD_1 <SEP> get<MAP>METHOD_5 <SEP> List<MAP>TYPE_2 <SEP> Arrays<MAP>TYPE_6 <SEP> Map<MAP>TYPE_1 <SEP> length_by_path<MAP>VAR_3 <SEP> 	
INF<MAP>VAR_5 <SEP> weight_by_edge<MAP>VAR_2 <SEP> HashMap<MAP>TYPE_5 <SEP> shortest_paths<MAP>METHOD_1 <SEP> i<MAP>VAR_6 <SEP> String<MAP>TYPE_2 <SEP> source<MAP>VAR_1 <SEP> Math<MAP>TYPE_6 <SEP> put<MAP>METHOD_3 <SEP> Integer<MAP>TYPE_3 <SEP> update_weight<MAP>VAR_7 <SEP> 0<MAP>INT_2 <SEP> 1<MAP>INT_1 <SEP> edge<MAP>VAR_4 <SEP> min<MAP>METHOD_6 <SEP> size<MAP>METHOD_5 <SEP> get<MAP>METHOD_4 <SEP> List<MAP>TYPE_4 <SEP> Map<MAP>TYPE_1 <SEP> keySet<MAP>METHOD_2 <SEP> weight_by_node<MAP>VAR_3 <SEP> 	
HashMap<MAP>TYPE_6 <SEP> ArrayList<MAP>TYPE_2 <SEP> String<MAP>TYPE_4 <SEP> getLast<MAP>METHOD_7 <SEP> put<MAP>METHOD_2 <SEP> precedence<MAP>VAR_2 <SEP> operator<MAP>VAR_6 <SEP> pop<MAP>METHOD_8 <SEP> isInstance<MAP>METHOD_3 <SEP> get<MAP>METHOD_6 <SEP> List<MAP>TYPE_1 <SEP> tokens<MAP>VAR_1 <SEP> "*"<MAP>STRING_3 <SEP> add<MAP>METHOD_4 <SEP> shunting_yard<MAP>METHOD_1 <SEP> rpntokens<MAP>VAR_3 <SEP> isEmpty<MAP>METHOD_5 <SEP> ArrayDeque<MAP>TYPE_7 <SEP> token<MAP>VAR_5 <SEP> Integer<MAP>TYPE_5 <SEP> 1<MAP>INT_1 <SEP> 100<MAP>INT_3 <SEP> 2<MAP>INT_2 <SEP> "/"<MAP>STRING_4 <SEP> "-"<MAP>STRING_2 <SEP> "+"<MAP>STRING_1 <SEP> Object<MAP>TYPE_8 <SEP> opstack<MAP>VAR_4 <SEP> Map<MAP>TYPE_3 <SEP> 	
Integer<MAP>TYPE_2 <SEP> add<MAP>METHOD_4 <SEP> 1<MAP>INT_2 <SEP> list_comp<MAP>METHOD_3 <SEP> primes<MAP>VAR_2 <SEP> 2<MAP>INT_1 <SEP> max<MAP>VAR_1 <SEP> ArrayList<MAP>TYPE_1 <SEP> sieve<MAP>METHOD_1 <SEP> any<MAP>METHOD_2 <SEP> n<MAP>VAR_3 <SEP> 	
epsilon<MAP>VAR_2 <SEP> abs<MAP>METHOD_2 <SEP> 2f<MAP>FLOAT_1 <SEP> sqrt<MAP>METHOD_1 <SEP> x<MAP>VAR_1 <SEP> 0.5f<MAP>FLOAT_2 <SEP> Math<MAP>TYPE_1 <SEP> approx<MAP>VAR_3 <SEP> 	
add<MAP>METHOD_2 <SEP> ret<MAP>VAR_4 <SEP> a<MAP>VAR_1 <SEP> rest<MAP>VAR_7 <SEP> b<MAP>VAR_2 <SEP> ArrayList<MAP>TYPE_1 <SEP> i<MAP>VAR_5 <SEP> k<MAP>VAR_3 <SEP> 0<MAP>INT_1 <SEP> 1<MAP>INT_3 <SEP> addAll<MAP>METHOD_3 <SEP> 50<MAP>INT_2 <SEP> subsequences<MAP>METHOD_1 <SEP> base<MAP>VAR_6 <SEP> 	
to_base<MAP>METHOD_1 <SEP> result<MAP>VAR_3 <SEP> 0<MAP>INT_1 <SEP> ""<MAP>STRING_1 <SEP> b<MAP>VAR_2 <SEP> valueOf<MAP>METHOD_2 <SEP> "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"<MAP>STRING_2 <SEP> num<MAP>VAR_1 <SEP> i<MAP>VAR_5 <SEP> String<MAP>TYPE_1 <SEP> alphabet<MAP>VAR_4 <SEP> charAt<MAP>METHOD_3 <SEP> 	
add<MAP>METHOD_4 <SEP> getSuccessors<MAP>METHOD_7 <SEP> Node<MAP>TYPE_2 <SEP> topological_ordering<MAP>METHOD_1 <SEP> containsAll<MAP>METHOD_8 <SEP> ArrayList<MAP>TYPE_1 <SEP> isEmpty<MAP>METHOD_3 <SEP> orderedNodes<MAP>VAR_2 <SEP> i<MAP>VAR_5 <SEP> listSize<MAP>VAR_4 <SEP> 0<MAP>INT_1 <SEP> node<MAP>VAR_3 <SEP> contains<MAP>METHOD_9 <SEP> size<MAP>METHOD_5 <SEP> directedGraph<MAP>VAR_1 <SEP> nextNode<MAP>VAR_6 <SEP> get<MAP>METHOD_6 <SEP> List<MAP>TYPE_3 <SEP> getPredecessors<MAP>METHOD_2 <SEP> 	
add<MAP>METHOD_5 <SEP> " "<MAP>STRING_1 <SEP> line<MAP>VAR_4 <SEP> ArrayList<MAP>TYPE_1 <SEP> length<MAP>METHOD_2 <SEP> String<MAP>TYPE_2 <SEP> substring<MAP>METHOD_4 <SEP> 0<MAP>INT_2 <SEP> lastIndexOf<MAP>METHOD_3 <SEP> 1<MAP>INT_1 <SEP> end<MAP>VAR_5 <SEP> text<MAP>VAR_1 <SEP> lines<MAP>VAR_3 <SEP> wrap<MAP>METHOD_1 <SEP> cols<MAP>VAR_2 <SEP> 	
